# savedsearches.conf

# Monitoring of data sources

[TrackMe - Data sources availability short term tracker]
cron_schedule = */5 * * * *
description = This scheduled report tracks and updates the data source availability KVstore based lookup
dispatch.earliest_time = -4h
dispatch.latest_time = now
enableSched = 1
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search  = | tstats max(_indextime) as current_data_last_ingest, max(_time) as current_data_last_time_seen where index=* sourcetype=* `trackme_tstats_main_filter` `apply_data_source_blacklists_data_retrieve` by index, sourcetype\
| eval current_data_last_lag_seen=now()-current_data_last_time_seen\
| rename index as data_index, sourcetype as data_sourcetype\
| append [ |inputlookup trackme_data_source_monitoring | eval key=_key]\
| stats first(key) as _key, first(*) as "*" by data_index, data_sourcetype\
| eval data_last_lag_seen=if(isnotnull(current_data_last_lag_seen), current_data_last_lag_seen, data_last_lag_seen)\
| eval data_last_time_seen=if(isnotnull(current_data_last_time_seen), current_data_last_time_seen, data_last_time_seen)\
| eval data_last_ingest=if(isnotnull(current_data_last_ingest), current_data_last_ingest, data_last_ingest)\
| fields - current_*\
| `trackme_default_monitored_state`\
| `trackme_default_lag`\
| `trackme_default_monitored_wdays`\
| eval data_override_lagging_class=if(isnull(data_override_lagging_class) OR data_override_lagging_class="null", "false", data_override_lagging_class)\
| lookup trackme_custom_lagging_definition name as data_index OUTPUTNEW value as data_custom_max_lag_allowed\
| lookup trackme_custom_lagging_definition name as data_sourcetype OUTPUTNEW value as data_custom_max_lag_allowed\
| eval data_max_lag_allowed	=if(isnum(data_custom_max_lag_allowed) AND data_override_lagging_class!="true", data_custom_max_lag_allowed, data_max_lag_allowed)\
| eval data_name=if(isnull(data_name), data_index . ":" . data_sourcetype, data_name)\
| search NOT [ | inputlookup trackme_audit_changes | where action="success" AND change_type="delete permanent" | eval _time=time/1000 | where _time>relative_time(now(), "-7d") | table object | dedup object | sort limit=0 object | rename object as data_name ]\
| eval data_monitoring_level=if(isnull(data_monitoring_level), "sourcetype", data_monitoring_level)\
| eventstats max(data_last_time_seen) as data_last_time_seen_idx, min(data_last_lag_seen) as data_last_lag_seen_idx by data_index\
| `trackme_data_sources_filtering`\
| `trackme_eval_data_source_state` | eval data_tracker_runtime=now()\
| lookup local=t trackme_data_source_monitoring data_name OUTPUT data_source_state as data_previous_source_state, data_tracker_runtime as data_previous_tracker_runtime\
| append [ | inputlookup trackme_audit_flip | where object_category="data_source" | eval _time=time | stats max(_time) as latest_flip_time, latest(object_state) as latest_flip_state by object | rename object as data_name ]\
| stats first(_key) as _key, first(*) as "*" by data_name\
| outputlookup trackme_data_source_monitoring append=t key_field=_key\
| lookup local=t trackme_data_source_monitoring data_name OUTPUT data_name as FOUND | where isnull(FOUND) | fields - FOUND\
| outputlookup trackme_data_source_monitoring append=t\
| stats count

[TrackMe - Data sources availability long term tracker]
cron_schedule = 1 * * * *
description = This scheduled report tracks and updates the data source availability KVstore based lookup
dispatch.earliest_time = -7d
dispatch.latest_time = now
enableSched = 1
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search  = | tstats max(_indextime) as current_data_last_ingest, max(_time) as current_data_last_time_seen where index=* sourcetype=* `trackme_tstats_main_filter` `apply_data_source_blacklists_data_retrieve` by index, sourcetype\
| eval current_data_last_lag_seen=now()-current_data_last_time_seen\
| rename index as data_index, sourcetype as data_sourcetype\
| append [ |inputlookup trackme_data_source_monitoring | eval key=_key]\
| stats first(key) as _key, first(*) as "*" by data_index, data_sourcetype\
| eval data_last_lag_seen=if(isnotnull(current_data_last_lag_seen), current_data_last_lag_seen, data_last_lag_seen)\
| eval data_last_time_seen=if(isnotnull(current_data_last_time_seen), current_data_last_time_seen, data_last_time_seen)\
| eval data_last_ingest=if(isnotnull(current_data_last_ingest), current_data_last_ingest, data_last_ingest)\
| fields - current_*\
| `trackme_default_monitored_state`\
| `trackme_default_lag`\
| `trackme_default_monitored_wdays`\
| eval data_override_lagging_class=if(isnull(data_override_lagging_class) OR data_override_lagging_class="null", "false", data_override_lagging_class)\
| lookup trackme_custom_lagging_definition name as data_index OUTPUTNEW value as data_custom_max_lag_allowed\
| lookup trackme_custom_lagging_definition name as data_sourcetype OUTPUTNEW value as data_custom_max_lag_allowed\
| eval data_max_lag_allowed	=if(isnum(data_custom_max_lag_allowed) AND data_override_lagging_class!="true", data_custom_max_lag_allowed, data_max_lag_allowed)\
| eval data_name=if(isnull(data_name), data_index . ":" . data_sourcetype, data_name)\
| search NOT [ | inputlookup trackme_audit_changes | where action="success" AND change_type="delete permanent" | eval _time=time/1000 | where _time>relative_time(now(), "-7d") | table object | dedup object | sort limit=0 object | rename object as data_name ]\
| eval data_monitoring_level=if(isnull(data_monitoring_level), "sourcetype", data_monitoring_level)\
| eventstats max(data_last_time_seen) as data_last_time_seen_idx, min(data_last_lag_seen) as data_last_lag_seen_idx by data_index\
| `trackme_data_sources_filtering`\
| `trackme_eval_data_source_state` | eval data_tracker_runtime=now()\
| lookup local=t trackme_data_source_monitoring data_name OUTPUT data_source_state as data_previous_source_state, data_tracker_runtime as data_previous_tracker_runtime\
| append [ | inputlookup trackme_audit_flip | where object_category="data_source" | eval _time=time | stats max(_time) as latest_flip_time, latest(object_state) as latest_flip_state by object | rename object as data_name ]\
| stats first(_key) as _key, first(*) as "*" by data_name\
| outputlookup trackme_data_source_monitoring append=t key_field=_key\
| lookup local=t trackme_data_source_monitoring data_name OUTPUT data_name as FOUND | where isnull(FOUND) | fields - FOUND\
| outputlookup trackme_data_source_monitoring append=t\
| stats count

[TrackMe - Data sources auto mode tracker update (updates value for data_wday_monitoring)]
cron_schedule = 0 2 * * *
description = This scheduled report tracks and updates the value for auto defined data_wday_monitoring
dispatch.earliest_time = -30d@d
dispatch.latest_time = now
enableSched = 1
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search  = | tstats max(_time) as current_data_last_time_seen where index=* `trackme_tstats_main_filter` `apply_data_source_blacklists_data_retrieve` by _time index, sourcetype span=1d\
| eval wday=strftime(_time, "%a")\
| streamstats count(eval(wday="Sat")) as saturday_seen, count(eval(wday="Sun")) as sunday_seen by index, sourcetype\
| stats max(saturday_seen) as saturday_seen, max(sunday_seen) as sunday_seen by index, sourcetype\
| eval auto_data_monitoring_wdays=case(saturday_seen>1 AND sunday_seen>1, "auto:all_days", saturday>1 AND sunday_seen<1, "auto:monday-to-saturday", saturday_seen<=1 AND sunday_seen<=1, "auto:monday-to-friday")\
| rename index as data_index, sourcetype as data_sourcetype | eval data_name = data_index . ":" . data_sourcetype\
| fields data_name, data_index, data_sourcetype, auto_data_monitoring_wdays\
| join data_name [ |inputlookup trackme_data_source_monitoring | eval key=_key]\
| eval data_monitoring_days=if(match(data_monitoring_days, "^manual:"), data_monitoring_days, auto_data_monitoring_wdays) | fields - auto_*\
| rename key as _key\
| outputlookup trackme_data_source_monitoring append=t key_field=_key\
| stats count

[TrackMe - Alert on data source availability]
alert.digest_mode = 0
alert.severity = 4
alert.suppress = 1
alert.suppress.fields = data_name, data_index, data_sourcetype
alert.suppress.period = 24h
alert.track = 1
counttype = number of events
cron_schedule = */5 * * * *
description = This alert will trigger if one or more of the data sources is seen as unavailable, with a default throttling period of 8 hours
dispatch.earliest_time = -5m
dispatch.latest_time = now
display.general.type = statistics
display.page.search.tab = statistics
display.visualizations.charting.chart = line
disabled = true
enableSched = 1
quantity = 0
relation = greater than
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search = | inputlookup trackme_data_source_monitoring\
| where data_monitored_state="enabled"\
| `trackme_eval_data_source_state`\
| `apply_data_source_blacklists`\
| where data_source_state="red"

# Monitoring of hosts

#
# Host monitoring
#

[TrackMe - hosts availability short term tracker]
cron_schedule = */5 * * * *
description = This scheduled report tracks and updates the data source availability KVstore based lookup
dispatch.earliest_time = -4h
dispatch.latest_time = now
enableSched = 1
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search  = | tstats max(_indextime) as current_data_last_ingest, max(_time) as current_data_last_time_seen where index=* sourcetype=* host=* host!="" `trackme_tstats_main_filter` `apply_data_host_blacklists_data_retrieve` by index, sourcetype, host\
| lookup trackme_custom_lagging_definition name as index OUTPUTNEW value as data_custom_max_lag_allowed\
| lookup trackme_custom_lagging_definition name as sourcetype OUTPUTNEW value as data_custom_max_lag_allowed\
| stats max(current_data_last_ingest) as current_data_last_ingest, max(current_data_last_time_seen) as current_data_last_time_seen, values(index) as index, values(sourcetype) as sourcetype, max(data_custom_max_lag_allowed) as data_custom_max_lag_allowed by host\
| eval current_data_last_lag_seen=now()-current_data_last_time_seen\
| rename host as data_host, index as data_index, sourcetype as data_sourcetype\
| eval data_host=upper(data_host)\
| search NOT [ | inputlookup trackme_audit_changes | where action="success" AND change_type="delete permanent" | eval _time=time/1000 | where _time>relative_time(now(), "-7d") | table object | dedup object | sort limit=0 object | rename object as data_host ]\
| stats max(current_data_last_ingest) as current_data_last_ingest, max(current_data_last_time_seen) as current_data_last_time_seen, min(current_data_last_lag_seen) as current_data_last_lag_seen, values(data_index) as data_index, values(data_sourcetype) as data_sourcetype, max(data_custom_max_lag_allowed) as data_custom_max_lag_allowed by data_host\
| append [ | inputlookup trackme_host_monitoring | eval key=_key | eval data_host=upper(data_host) | makemv delim="," data_index | makemv delim="," data_sourcetype ]\
| stats first(key) as key, values(data_index) as data_index, values(data_sourcetype) as data_sourcetype, first(*) as "*" by data_host\
| eval data_last_ingest=if(isnotnull(current_data_last_ingest), current_data_last_ingest, data_last_ingest)\
| eval data_last_lag_seen=if(isnotnull(current_data_last_lag_seen), current_data_last_lag_seen, data_last_lag_seen)\
| eval data_last_time_seen=if(isnotnull(current_data_last_time_seen), current_data_last_time_seen, data_last_time_seen)\
| `trackme_default_host_monitored_state`\
| `trackme_default_host_lag`\
| `trackme_default_host_monitored_wdays`\
| eval data_override_lagging_class=if(isnull(data_override_lagging_class) OR data_override_lagging_class="null", "false", data_override_lagging_class)\
| eval data_max_lag_allowed	=if(isnum(data_custom_max_lag_allowed) AND data_override_lagging_class!="true", data_custom_max_lag_allowed, data_max_lag_allowed)\
| rename key as _key\
| eval data_index=mvdedup(data_index), data_sourcetype=mvdedup(data_sourcetype)\
| eval data_index=mvjoin(data_index, ","), data_sourcetype=mvjoin(data_sourcetype, ",")\
| `trackme_eval_data_host_state` | eval data_tracker_runtime=now()\
| lookup local=t trackme_host_monitoring data_host OUTPUT data_host_state as data_previous_host_state, data_tracker_runtime as data_previous_tracker_runtime\
| append [ | inputlookup trackme_audit_flip | where object_category="data_host" | eval _time=time | stats max(_time) as latest_flip_time, latest(object_state) as latest_flip_state by object | rename object as data_host ]\
| stats first(_key) as _key, first(*) as "*" by data_host\
| outputlookup trackme_host_monitoring append=t key_field=_key\
| lookup local=t trackme_host_monitoring data_host OUTPUT data_host as FOUND | where isnull(FOUND) | fields - FOUND\
| outputlookup trackme_host_monitoring append=t\
| stats count

[TrackMe - hosts availability long term tracker]
cron_schedule = 1 * * * *
description = This scheduled report tracks and updates the data source availability KVstore based lookup
dispatch.earliest_time = -7d
dispatch.latest_time = now
enableSched = 1
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search  = | tstats max(_indextime) as current_data_last_ingest, max(_time) as current_data_last_time_seen where index=* sourcetype=* host=* host!="" `trackme_tstats_main_filter` `apply_data_host_blacklists_data_retrieve` by index, sourcetype, host\
| lookup trackme_custom_lagging_definition name as index OUTPUTNEW value as data_custom_max_lag_allowed\
| lookup trackme_custom_lagging_definition name as sourcetype OUTPUTNEW value as data_custom_max_lag_allowed\
| stats max(current_data_last_ingest) as current_data_last_ingest, max(current_data_last_time_seen) as current_data_last_time_seen, values(index) as index, values(sourcetype) as sourcetype, max(data_custom_max_lag_allowed) as data_custom_max_lag_allowed by host\
| eval current_data_last_lag_seen=now()-current_data_last_time_seen\
| rename host as data_host, index as data_index, sourcetype as data_sourcetype\
| eval data_host=upper(data_host)\
| search NOT [ | inputlookup trackme_audit_changes | where action="success" AND change_type="delete permanent" | eval _time=time/1000 | where _time>relative_time(now(), "-7d") | table object | dedup object | sort limit=0 object | rename object as data_host ]\
| stats max(current_data_last_ingest) as current_data_last_ingest, max(current_data_last_time_seen) as current_data_last_time_seen, min(current_data_last_lag_seen) as current_data_last_lag_seen, values(data_index) as data_index, values(data_sourcetype) as data_sourcetype, max(data_custom_max_lag_allowed) as data_custom_max_lag_allowed by data_host\
| append [ | inputlookup trackme_host_monitoring | eval key=_key | eval data_host=upper(data_host) | makemv delim="," data_index | makemv delim="," data_sourcetype ]\
| stats first(key) as key, values(data_index) as data_index, values(data_sourcetype) as data_sourcetype, first(*) as "*" by data_host\
| eval data_last_ingest=if(isnotnull(current_data_last_ingest), current_data_last_ingest, data_last_ingest)\
| eval data_last_lag_seen=if(isnotnull(current_data_last_lag_seen), current_data_last_lag_seen, data_last_lag_seen)\
| eval data_last_time_seen=if(isnotnull(current_data_last_time_seen), current_data_last_time_seen, data_last_time_seen)\
| `trackme_default_host_monitored_state`\
| `trackme_default_host_lag`\
| `trackme_default_host_monitored_wdays`\
| eval data_override_lagging_class=if(isnull(data_override_lagging_class) OR data_override_lagging_class="null", "false", data_override_lagging_class)\
| eval data_max_lag_allowed	=if(isnum(data_custom_max_lag_allowed) AND data_override_lagging_class!="true", data_custom_max_lag_allowed, data_max_lag_allowed)\
| rename key as _key\
| eval data_index=mvdedup(data_index), data_sourcetype=mvdedup(data_sourcetype)\
| eval data_index=mvjoin(data_index, ","), data_sourcetype=mvjoin(data_sourcetype, ",")\
| `trackme_eval_data_host_state` | eval data_tracker_runtime=now()\
| lookup local=t trackme_host_monitoring data_host OUTPUT data_host_state as data_previous_host_state, data_tracker_runtime as data_previous_tracker_runtime\
| append [ | inputlookup trackme_audit_flip | where object_category="data_host" | eval _time=time | stats max(_time) as latest_flip_time, latest(object_state) as latest_flip_state by object | rename object as data_host ]\
| stats first(_key) as _key, first(*) as "*" by data_host\
| outputlookup trackme_host_monitoring append=t key_field=_key\
| lookup local=t trackme_host_monitoring data_host OUTPUT data_host as FOUND | where isnull(FOUND) | fields - FOUND\
| outputlookup trackme_host_monitoring append=t\
| stats count

[TrackMe - Data hosts auto mode tracker update (updates value for data_wday_monitoring)]
cron_schedule = 0 3 * * *
description = This scheduled report tracks and updates the value for auto defined data_wday_monitoring
dispatch.earliest_time = -30d@d
dispatch.latest_time = now
enableSched = 1
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search  = | tstats max(_time) as current_data_last_time_seen where index=* `trackme_tstats_main_filter` `apply_data_host_blacklists_data_retrieve` by _time host span=1d\
| eval wday=strftime(_time, "%a")\
| streamstats count(eval(wday="Sat")) as saturday_seen, count(eval(wday="Sun")) as sunday_seen by host\
| stats max(saturday_seen) as saturday_seen, max(sunday_seen) as sunday_seen by host\
| eval auto_data_monitoring_wdays=case(saturday_seen>1 AND sunday_seen>1, "auto:all_days", saturday>1 AND sunday_seen<1, "auto:monday-to-saturday", saturday_seen<=1 AND sunday_seen<=1, "auto:monday-to-friday")\
| rename host as data_host\
| eval data_host=upper(data_host)\
| fields data_host, auto_data_monitoring_wdays\
| join data_host [ |inputlookup trackme_host_monitoring | eval key=_key | eval data_host=upper(data_host) ]\
| eval data_monitoring_days=if(match(data_monitoring_days, "^manual:"), data_monitoring_days, auto_data_monitoring_wdays) | fields - auto_*\
| rename key as _key\
| outputlookup trackme_host_monitoring append=t key_field=_key\
| stats count

[TrackMe - Alert on data host availability]
alert.digest_mode = 0
alert.severity = 4
alert.suppress = 1
alert.suppress.fields = data_host
alert.suppress.period = 24h
alert.track = 1
counttype = number of events
cron_schedule = */5 * * * *
description = This alert will trigger if one or more of the data hosts is seen as unavailable, with a default throttling period of 8 hours
dispatch.earliest_time = -5m
dispatch.latest_time = now
display.general.type = statistics
display.page.search.tab = statistics
display.visualizations.charting.chart = line
disabled = true
enableSched = 1
quantity = 0
relation = greater than
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search = | inputlookup trackme_host_monitoring\
| where data_monitored_state="enabled"\
| `trackme_eval_data_host_state`\
| `apply_data_host_blacklists`\
| where data_host_state="red"

# Various

[TrackMe - Audit changes night purge]
cron_schedule = 30 3 * * *
description = This scheduled report purges old entries from the audit changes collection
dispatch.earliest_time = -5m
dispatch.latest_time = now
enableSched = 1
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search  = | inputlookup trackme_audit_changes | sort limit=0 - time | eval _time=time/1000\
| `trackme_audit_changes_retention`\
| outputlookup trackme_audit_changes\
| stats count

[TrackMe - Flip state night purge]
cron_schedule = 0 4 * * *
description = This scheduled report purges old entries from the flip state collection
dispatch.earliest_time = -5m
dispatch.latest_time = now
enableSched = 1
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search  = | inputlookup trackme_audit_flip | sort limit=0 - time | eval _time=time\
| `trackme_flip_state_retention`\
| outputlookup trackme_audit_flip\
| stats count

# Track flip state

[TrackMe - Flip state change tracker]
cron_schedule = 1-56/5 * * * *
description = This scheduled report tracks and updates the flip state KVstore based lookup
dispatch.earliest_time = -5m
dispatch.latest_time = now
enableSched = 1
request.ui_dispatch_app = trackme
request.ui_dispatch_view = trackme
search  = | inputlookup trackme_data_source_monitoring | where data_monitored_state="enabled"\
| inputlookup append=t trackme_host_monitoring | where data_monitored_state="enabled"\
| where (data_source_state!=data_previous_source_state) OR (data_host_state!=data_previous_host_state)\
| eval time=data_tracker_runtime\
| eval data_tracker_runtime=strftime(data_tracker_runtime, "%d/%m/%Y %H:%M:%S")\
| eval object=case(isnotnull(data_name), data_name, isnotnull(data_host), data_host)\
| eval object_category=case(isnotnull(data_name), "data_source", isnotnull(data_host), "data_host")\
| eval object_previous_state=case(isnotnull(data_previous_source_state), data_previous_source_state, isnotnull(data_previous_host_state), data_previous_host_state)\
| eval object_state=case(isnotnull(data_source_state), data_source_state, isnotnull(data_host_state), data_host_state)\
| eval result = data_tracker_runtime . ", object=" . object . " has flipped from previous_state=" . object_previous_state . " to state=" . object_state\
| table time, object, object_category, result, object_previous_state, object_state\
| lookup trackme_audit_flip time, object, object_category OUTPUT result as FOUND | where isnull(FOUND) | fields - FOUND\
| outputlookup trackme_audit_flip append=t\
| stats count
